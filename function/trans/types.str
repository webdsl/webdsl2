module function/trans/types

imports 
  include/WebDSL
  function/trans/signatures
  lib/nbl/-
  lib/task/-
  lib/types/-
  lib/editor-common.generated
 
rules  	
  	
  	
  	  
  type-error:
  	//Task(_, [], Choice(results,error), _) -> (node, message)
  	Error(error) -> (error, message)
    where message := <map(is-string <+ pp-webdsl-string); concat-strings <+ !"default error message"> error

  type-error:
  	Task(_, [], t@PropCheck(current, expected*), _) -> (t, <type-error-message-after-eval> (current,expected*))

  type-error-message-after-eval :
  	(current, expected*) -> $[Type error found: [<pp-webdsl-string> current], expected: [<map(pp-webdsl-string);concat-strings> expected*]]

rules

  type-error-message-before-eval :
  	(current, expected*) -> ["Type error found: ", current,", expected: ",expected*]
	
  create-type(|task*) : 
  	type -> <new-task(|task*)> PropCalc(type,[]) // only need second argument (list of dependencies) if type tasks are used in the calculation but not contained in end result 
 
  type-check(|task*) :
    (current, expected*) -> <new-task(|task*)> Choice(<map(create-check-task(|current,task*))> expected*,[message])
    with message := <type-error-message-before-eval> (current,expected*)
    
  create-check-task(|current,task*) : 
  	x -> <new-task(|task*)> PropCheck(current, x)

  type-of(|task*) = 
  	try(type-task(|task*))
    
  check-is-bool(|task*) : e -> <type-check(|task*)> (<type-of(|task*)> e, [SimpleSort("Bool")])
  check-is-int(|task*) : e -> <type-check(|task*)> (<type-of(|task*)> e, [SimpleSort("Int")])
    
  set-of  : 
  	type -> GenericSort("Set",[type])
  	
  list-of : 
  	type -> GenericSort("List",[type]) 

rules // literals

  type-task(|task*): String(_) -> <create-type(|task*)> SimpleSort("String")
  type-task(|task*): Int(_)    -> <create-type(|task*)> SimpleSort("Int")
  type-task(|task*): Float(_)  -> <create-type(|task*)> SimpleSort("Float")
  type-task(|task*): True()    -> <create-type(|task*)> SimpleSort("Bool")
  type-task(|task*): False()   -> <create-type(|task*)> SimpleSort("Bool") 
  
rules // statements  		
  		
  type-task(|task*):
    If(e, b1, b2) -> <id>
    where <check-is-bool(|task*)> e

  type-task(|task*):
    ForStmt(x, t, e, _, _) -> <id>
    where <type-check(|task*)> (<type-of(|task*)> e, [<set-of> t, <list-of> t])
  
  type-task(|task*):  
    ForCountStmt(_, e1, e2, _) -> <id>
    where <check-is-int(|task*)> e1
    where <check-is-int(|task*)> e2

rules // expressions  	
	 
  type-task(|task*): 
  	Not(e) -> <create-type(|task*)> SimpleSort("Bool")
  	where <check-is-bool(|task*)> e

  type-task(|task*):
    IfExp(e, e1, e2) -> e1t
    where <check-is-bool(|task*)> e
    where e1t := <type-of(|task*)> e1
        ; e2t := <type-of(|task*)> e2
        ; <type-check(|task*)> (e2t, [e1t]) // or subtype of e1t
          
  type-task(|task*):
  	ForExp(e, _, srt, ecol, _) -> <create-type(|task*)> <list-of> et
    where ecolt := <type-of(|task*)> ecol
        ; <type-check(|task*)> (ecolt, [<set-of> srt, <list-of> srt])
    where et := <type-of(|task*)> e
  
  type-task(|task*):
  	AndForExp(e) -> <create-type(|task*)> SimpleSort("Bool")
    where et := <type-of(|task*)> e
        ; <type-check(|task*)> (et, [<set-of> SimpleSort("Bool"), <list-of> SimpleSort("Bool")])
          
  type-task(|task*):
  	OrForExp(e) -> <create-type(|task*)> SimpleSort("Bool")
    where et := <type-of(|task*)> e
        ; <type-check(|task*)> (et, [<set-of> SimpleSort("Bool"), <list-of> SimpleSort("Bool")])
          
  type-task(|task*):
  	CollectionIndex(e_col,e_index) -> <create-type(|task*)> type
    where e_colt := <type-of(|task*)> e_col
    	; <type-check(|task*)> (e_colt, [GenericSort("List",SimpleSort("TODO should match any type"))])
    where <check-is-int(|task*)> e_index
    where GenericSort(_,[type]) := e_colt
          
rules // for loop filter  
	
  type-task(|task*): Filter(we, _, _)           -> <check-is-bool(|task*)> we
  type-task(|task*): FilterNoLimit(we, _)       -> <check-is-bool(|task*)> we
  type-task(|task*): FilterNoOrderBy(we, _)     -> <check-is-bool(|task*)> we
  type-task(|task*): FilterNoOrderByNoLimit(we) -> <check-is-bool(|task*)> we

  type-task(|task*): Limit(lim,off)     -> <check-is-int(|task*)> lim
  type-task(|task*): Limit(lim,off)     -> <check-is-int(|task*)> off
  type-task(|task*): LimitNoOffset(lim) -> <check-is-int(|task*)> lim
  type-task(|task*): LimitNoLimit(off)  -> <check-is-int(|task*)> off
  