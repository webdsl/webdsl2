module function/trans/types

imports 
  include/WebDSL
  function/trans/signatures
  lib/nbl/-
  lib/task/-
  lib/types/-
  lib/editor-common.generated
 
rules  	
  	  
  type-error:
  	Task(_, [], Choice(results,error)) -> (node, message)
    where node := <Hd> results // needs to be changed to fix origin tracking
        ; message := <map(is-string <+ pp-webdsl-string); concat-strings> error

  type-error:
  	Task(_, [], t@PropCheck(current, expected*)) -> (t, <type-error-message-after-eval> (current,expected*))

  type-error-message-after-eval :
  	(current, expected*) -> $[Type error found: [<pp-webdsl-string> current], expected: [<map(pp-webdsl-string);concat-strings> expected*]]

rules

  type-error-message-before-eval :
  	(current, expected*) -> ["Type error found: ", current,", expected: ",expected*]
	
  create-type(|task*) : 
  	type -> <new-task(|task*)> PropCalc(type,[]) // only need second argument (list of dependencies) if type tasks are used in the calculation but not contained in end result 
 
  type-check(|task*) :
    (current, expected*) -> <new-task(|task*)> Choice(<map(create-check-task(|current,task*))> expected*,[message])
    with message := <type-error-message-before-eval> (current,expected*)
    
  create-check-task(|current,task*) : 
  	x -> <new-task(|task*)> PropCheck(current, x)

  type-of(|task*) = 
  	try(type-task(|task*))
    
  set-of  : 
  	type -> GenericSort("Set",[type])
  	
  list-of : 
  	type -> GenericSort("List",[type]) 

rules // literals

  type-task(|task*): String(_) -> <create-type(|task*)> SimpleSort("String")
  type-task(|task*): Int(_)    -> <create-type(|task*)> SimpleSort("Int")
  type-task(|task*): Float(_)  -> <create-type(|task*)> SimpleSort("Float")
  type-task(|task*): True()    -> <create-type(|task*)> SimpleSort("Bool")
  type-task(|task*): False()   -> <create-type(|task*)> SimpleSort("Bool") 
  
rules // statements  		
  		
  type-task(|task*):
    If(e, b1, b2) -> <id>
    where <type-check(|task*)> (<type-of(|task*)> e, [SimpleSort("Bool")])

  type-task(|task*):
    ForStmt(x, t, e, _, _) -> <id>
    where <type-check(|task*)> (<type-of(|task*)> e, [<set-of> t, <list-of> t])
  
  type-task(|task*):  
    ForCountStmt(_, e1, e2, _) -> <id>
    where <type-check(|task*)> (<type-of(|task*)> e1, [SimpleSort("Int")])
        ; <type-check(|task*)> (<type-of(|task*)> e2, [SimpleSort("Int")])

rules // expressions  	
	 
  type-task(|task*): 
  	Not(e) -> <create-type(|task*)> SimpleSort("Bool")
  	where <type-check(|task*)> (<type-of(|task*)> e, [SimpleSort("Bool")])

  type-task(|task*):
    IfExp(e, e1, e2) -> e1t
    where <type-check(|task*)> (<type-of(|task*)> e, [SimpleSort("Bool")])
        ; e1t := <type-of(|task*)> e1
        ; e2t := <type-of(|task*)> e2
        ; <type-check(|task*)> (e2t, [e1t]) // or subtype of e1t
          
  type-task(|task*):
  	ForExp(e, _, srt, ecol, _) -> <create-type(|task*)> <list-of> et
    where ecolt := <type-of(|task*)> ecol
        ; <type-check(|task*)> (ecolt, [<set-of> srt, <list-of> srt])
        ; et := <type-of(|task*)> e
  
  type-task(|task*):
  	AndForExp(e) -> <create-type(|task*)> SimpleSort("Bool")
    where et := <type-of(|task*)> e
        ; <type-check(|task*)> (et, [<set-of> SimpleSort("Bool"), <list-of> SimpleSort("Bool")])
          
  type-task(|task*):
  	OrForExp(e) -> <create-type(|task*)> SimpleSort("Bool")
    where et := <type-of(|task*)> e
        ; <type-check(|task*)> (et, [<set-of> SimpleSort("Bool"), <list-of> SimpleSort("Bool")])
  
