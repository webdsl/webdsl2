module WebDSL-Type

imports
  WebDSL-Lexical
  WebDSL-DataModel
	WebDSL-Action
	
exports

  context-free syntax
    Id         -> QId
    QId "." Id -> QId {cons("Qualified")}

  context-free syntax %% Types
    SimpleSort -> Sort
		VoidSort -> Sort
    GenericSort -> Sort
    RefSort -> Sort
    FunctionSort -> Sort
		
    Id                     -> SimpleSort {cons("SimpleSort")}
    Id "<" Sort ">" -> GenericSort {cons("GenericSort")}
    "Ref" "<" Sort ">" -> RefSort {cons("RefSort")}
    "Ref" "<" Sort ">" -> GenericSort {reject}

    %% List type '[Type]' and Set type '{Type}' notation
    "[" Sort "]" -> GenericSort {ast("GenericSort(\"List\",[<1>])")}
    "{" Sort "}" -> GenericSort  {ast("GenericSort(\"Set\",[<1>])")}

		-> VoidSort				{ast("Void")}

		"function" "(" {Sort ","}* ")" FunctionReturn -> FunctionSort {"FunctionSort"}

  context-free syntax
  
    %%  Construct for creating custom value types, and altering the existing value types.
    %%
    %%  example: 
    %%    type String { validate(this.length() <= 255 , "input too long (max 255 characters)") }
    %%    type USDate : Date { format = "MM/dd/yyyy" }
    %% 
    %%  Will also need to cope with input/output decode/encode.
    %%

    "type" Id "{" TypeProperty* "}" -> Definition {cons("TypeDef")}
    
    Annotation -> TypeProperty {cons("TypeDefAnno")}
    
    NativeClassFunction -> TypeProperty
    %%solve ambiguities
    "static" -> TypeProperty {reject}
    
    QId "as" NativeClassFunction -> TypeProperty{cons("NativeClassFunctionFromStatic")}
    
    
    